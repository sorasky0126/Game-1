<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>React ãƒ‡ãƒãƒƒã‚°ç‰ˆ</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 50px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    #root {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }
    button:hover {
      background: #0056b3;
    }
    h1 {
      color: #333;
      margin-bottom: 20px;
    }
    #status {
      background: #fff3cd;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
      border-left: 4px solid #ffc107;
    }
  </style>
</head>
<body>
  <div id="status">èª­ã¿è¾¼ã¿ä¸­...</div>
  <div id="root"></div>

  <!-- React ã¨ ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  
  <!-- Babel Standalone -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- React ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ -->
  <script type="text/babel">
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
import React, { useState, useEffect } from 'react';
import { RotateCcw, Lightbulb } from 'lucide-react';

const ChainBreaker = () => {
  const [grid, setGrid] = useState([]);
  const [selected, setSelected] = useState([]);
  const [score, setScore] = useState(0);
  const [moves, setMoves] = useState(15);
  const [level, setLevel] = useState(1);
  const [gameOver, setGameOver] = useState(false);
  const [showHint, setShowHint] = useState(false);

  const colors = ['ğŸ”´', 'ğŸ”µ', 'ğŸŸ¢', 'ğŸŸ¡', 'ğŸŸ£'];
  
  useEffect(() => {
    initializeGame();
  }, [level]);

  const initializeGame = () => {
    const size = 6;
    const newGrid = [];
    for (let i = 0; i < size; i++) {
      const row = [];
      for (let j = 0; j < size; j++) {
        row.push({
          color: colors[Math.floor(Math.random() * Math.min(3 + level, colors.length))],
          id: `${i}-${j}`
        });
      }
      newGrid.push(row);
    }
    setGrid(newGrid);
    setSelected([]);
    setGameOver(false);
  };

  const isAdjacent = (cell1, cell2) => {
    const [r1, c1] = cell1.split('-').map(Number);
    const [r2, c2] = cell2.split('-').map(Number);
    return Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1;
  };

  const handleCellClick = (rowIdx, colIdx) => {
    if (gameOver || moves === 0) return;
    
    const cellId = `${rowIdx}-${colIdx}`;
    const cell = grid[rowIdx][colIdx];
    
    if (selected.length === 0) {
      setSelected([{ id: cellId, color: cell.color }]);
    } else {
      const lastSelected = selected[selected.length - 1];
      
      if (cellId === lastSelected.id) {
        return;
      }
      
      if (selected.some(s => s.id === cellId)) {
        const idx = selected.findIndex(s => s.id === cellId);
        setSelected(selected.slice(0, idx + 1));
        return;
      }
      
      if (cell.color === lastSelected.color && isAdjacent(cellId, lastSelected.id)) {
        setSelected([...selected, { id: cellId, color: cell.color }]);
      }
    }
  };

  const confirmSelection = () => {
    if (selected.length < 3) {
      setSelected([]);
      return;
    }

    const points = selected.length * selected.length * 10;
    setScore(score + points);
    setMoves(moves - 1);

    const newGrid = grid.map(row => row.map(cell => ({ ...cell })));
    
    selected.forEach(sel => {
      const [r, c] = sel.id.split('-').map(Number);
      newGrid[r][c] = null;
    });

    for (let col = 0; col < newGrid[0].length; col++) {
      let writeIdx = newGrid.length - 1;
      for (let row = newGrid.length - 1; row >= 0; row--) {
        if (newGrid[row][col] !== null) {
          if (writeIdx !== row) {
            newGrid[writeIdx][col] = newGrid[row][col];
            newGrid[writeIdx][col].id = `${writeIdx}-${col}`;
            newGrid[row][col] = null;
          }
          writeIdx--;
        }
      }
      
      for (let row = writeIdx; row >= 0; row--) {
        newGrid[row][col] = {
          color: colors[Math.floor(Math.random() * Math.min(3 + level, colors.length))],
          id: `${row}-${col}`
        };
      }
    }

    setGrid(newGrid);
    setSelected([]);

    if (moves - 1 === 0) {
      checkGameOver(points);
    }
  };

  const checkGameOver = (lastPoints) => {
    const finalScore = score + lastPoints;
    const target = 500 * level;
    
    if (finalScore >= target) {
      setLevel(level + 1);
      setMoves(15);
      setScore(0);
    } else {
      setGameOver(true);
    }
  };

  const resetGame = () => {
    setLevel(1);
    setScore(0);
    setMoves(15);
    initializeGame();
  };

  const findBestMove = () => {
    let bestChain = [];
    
    for (let r = 0; r < grid.length; r++) {
      for (let c = 0; c < grid[0].length; c++) {
        const chain = findChainFrom(r, c);
        if (chain.length > bestChain.length) {
          bestChain = chain;
        }
      }
    }
    
    if (bestChain.length >= 3) {
      setSelected(bestChain);
      setShowHint(false);
    }
  };

  const findChainFrom = (startR, startC) => {
    const color = grid[startR][startC].color;
    const visited = new Set();
    const chain = [];
    
    const dfs = (r, c) => {
      const id = `${r}-${c}`;
      if (visited.has(id)) return;
      if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return;
      if (grid[r][c].color !== color) return;
      
      visited.add(id);
      chain.push({ id, color });
      
      dfs(r + 1, c);
      dfs(r - 1, c);
      dfs(r, c + 1);
      dfs(r, c - 1);
    };
    
    dfs(startR, startC);
    return chain;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 p-4 flex items-center justify-center">
      <div className="max-w-2xl w-full bg-white/10 backdrop-blur-lg rounded-3xl p-8 shadow-2xl">
        <div className="text-center mb-6">
          <h1 className="text-4xl font-bold text-white mb-2">â›“ï¸ ãƒã‚§ã‚¤ãƒ³ãƒ–ãƒ¬ã‚¤ã‚«ãƒ¼</h1>
          <p className="text-blue-200 text-sm">åŒã˜è‰²ã‚’ç¹‹ã’ã¦æ¶ˆãã†ï¼3å€‹ä»¥ä¸Šã§å¾—ç‚¹</p>
        </div>

        <div className="flex justify-between items-center mb-6 bg-white/20 rounded-2xl p-4">
          <div className="text-center">
            <div className="text-yellow-300 text-sm font-semibold">ãƒ¬ãƒ™ãƒ«</div>
            <div className="text-white text-2xl font-bold">{level}</div>
          </div>
          <div className="text-center">
            <div className="text-green-300 text-sm font-semibold">ã‚¹ã‚³ã‚¢</div>
            <div className="text-white text-2xl font-bold">{score}</div>
          </div>
          <div className="text-center">
            <div className="text-red-300 text-sm font-semibold">æ®‹ã‚Šæ‰‹æ•°</div>
            <div className="text-white text-2xl font-bold">{moves}</div>
          </div>
        </div>

        <div className="mb-4 text-center">
          <div className="inline-block bg-white/20 rounded-xl p-2">
            {selected.length > 0 && (
              <span className="text-white font-semibold">
                é¸æŠä¸­: {selected.length}å€‹ â†’ {selected.length >= 3 ? `${selected.length * selected.length * 10}ç‚¹` : '3å€‹ä»¥ä¸Šå¿…è¦'}
              </span>
            )}
            {selected.length === 0 && (
              <span className="text-blue-200">åŒã˜è‰²ã®éš£æ¥ã‚»ãƒ«ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ç¹‹ã’ã‚ˆã†</span>
            )}
          </div>
        </div>

        <div className="bg-white/10 rounded-2xl p-4 mb-6">
          <div className="grid gap-2" style={{ gridTemplateColumns: `repeat(${grid[0]?.length || 6}, 1fr)` }}>
            {grid.map((row, rowIdx) =>
              row.map((cell, colIdx) => {
                const isSelected = selected.some(s => s.id === cell.id);
                const selectedIndex = selected.findIndex(s => s.id === cell.id);
                
                return (
                  <button
                    key={cell.id}
                    onClick={() => handleCellClick(rowIdx, colIdx)}
                    className={`aspect-square rounded-xl text-4xl flex items-center justify-center transition-all duration-200 transform hover:scale-110 ${
                      isSelected
                        ? 'bg-yellow-400 ring-4 ring-yellow-300 scale-110 shadow-lg'
                        : 'bg-white/30 hover:bg-white/50'
                    }`}
                  >
                    {cell.color}
                    {isSelected && (
                      <span className="absolute text-xs font-bold text-black bg-white rounded-full w-5 h-5 flex items-center justify-center -top-1 -right-1">
                        {selectedIndex + 1}
                      </span>
                    )}
                  </button>
                );
              })
            )}
          </div>
        </div>

        <div className="flex gap-3 mb-4">
          <button
            onClick={confirmSelection}
            disabled={selected.length < 3 || gameOver}
            className={`flex-1 py-4 rounded-xl font-bold text-lg transition-all ${
              selected.length >= 3 && !gameOver
                ? 'bg-gradient-to-r from-green-400 to-blue-500 text-white hover:from-green-500 hover:to-blue-600 shadow-lg transform hover:scale-105'
                : 'bg-gray-500/50 text-gray-300 cursor-not-allowed'
            }`}
          >
            æ±ºå®šï¼
          </button>
          
          <button
            onClick={() => setSelected([])}
            disabled={selected.length === 0 || gameOver}
            className="px-6 py-4 bg-red-500/80 text-white rounded-xl font-bold hover:bg-red-600 transition-all disabled:bg-gray-500/50 disabled:text-gray-300"
          >
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </button>
        </div>

        <div className="flex gap-3">
          <button
            onClick={findBestMove}
            className="flex-1 flex items-center justify-center gap-2 py-3 bg-yellow-500/80 text-white rounded-xl font-semibold hover:bg-yellow-600 transition-all"
          >
            <Lightbulb size={20} />
            ãƒ’ãƒ³ãƒˆ
          </button>
          
          <button
            onClick={resetGame}
            className="flex items-center justify-center gap-2 px-6 py-3 bg-purple-500/80 text-white rounded-xl font-semibold hover:bg-purple-600 transition-all"
          >
            <RotateCcw size={20} />
            ãƒªã‚»ãƒƒãƒˆ
          </button>
        </div>

        {gameOver && (
          <div className="mt-6 bg-red-500/90 text-white rounded-2xl p-6 text-center">
            <h2 className="text-2xl font-bold mb-2">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
            <p className="mb-4">ãƒ¬ãƒ™ãƒ«{level} - æœ€çµ‚ã‚¹ã‚³ã‚¢: {score}ç‚¹</p>
            <p className="text-sm mb-4">ç›®æ¨™ã‚¹ã‚³ã‚¢ {500 * level}ç‚¹ã«å±Šãã¾ã›ã‚“ã§ã—ãŸ</p>
            <button
              onClick={resetGame}
              className="bg-white text-red-600 px-8 py-3 rounded-xl font-bold hover:bg-gray-100 transition-all"
            >
              ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦
            </button>
          </div>
        )}

        <div className="mt-6 bg-white/10 rounded-2xl p-4">
          <h3 className="text-white font-bold mb-2">ğŸ“– ãƒ«ãƒ¼ãƒ«</h3>
          <ul className="text-blue-200 text-sm space-y-1">
            <li>â€¢ åŒã˜è‰²ã®éš£æ¥ã™ã‚‹ã‚»ãƒ«ã‚’ç¹‹ã’ã¦é¸æŠ</li>
            <li>â€¢ 3å€‹ä»¥ä¸Šç¹‹ã’ã‚‹ã¨æ¶ˆã›ã‚‹ï¼ˆå¾—ç‚¹ = å€‹æ•°Â² Ã— 10ï¼‰</li>
            <li>â€¢ 15æ‰‹ä»¥å†…ã«ç›®æ¨™ã‚¹ã‚³ã‚¢ã‚’é”æˆã™ã‚‹ã¨ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—</li>
            <li>â€¢ ãƒ¬ãƒ™ãƒ«ãŒä¸ŠãŒã‚‹ã¨ä½¿ãˆã‚‹è‰²ãŒå¢—ãˆã¦é›£ã—ããªã‚‹</li>
            <li>â€¢ é•·ã„ãƒã‚§ã‚¤ãƒ³ã‚’ä½œã‚‹ã¨é«˜å¾—ç‚¹ï¼</li>
          </ul>
        </div>
      </div>
    </div>
  );
};

export default ChainBreaker;
  </script>
</body>
</html>
